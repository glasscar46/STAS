import abc
import copy
import io
from typing import Any, List
from .sample_interface import ISample

class IModel(metaclass=abc.ABCMeta):
    """
    A base class for a model used in the annotation process. 

    This class defines the structure and behavior expected from any model 
    used to generate annotations for a given set of samples. Models 
    that inherit from this class must implement methods to finetune 
    on annotated samples and generate annotations for new samples.
    """

    def __init__(self) -> None:
        """
        Initializes the model.

        The model ID is initially set to None, and this is meant to be 
        assigned later, typically once the model is saved or persisted 
        in a database.
        """
        self.id = None
    
    def copy(self):
        """
        Creates a deep copy of the model object.

        This method creates a new instance of the model with the same attributes, 
        but resets the `id` attribute to `None` to allow this new instance 
        to be treated as an independent object.

        Returns:
            IModel: A new deep-copied instance of the model with the same 
                    attributes, except for the `id` which is set to `None`.
        """
        new_object = copy.deepcopy(self)
        new_object.id = None
        return new_object

    def load(self, model_bytes:io.BytesIO):
        """Loads the model from BytesIO buffer."""
        raise NotImplementedError
    
    def save(self) -> io.BytesIO:
        """
        Save the model to a BytesIO buffer.
        """
        raise NotImplementedError

    @abc.abstractmethod
    def finetune(self, samples: List[ISample]):
        """
        Finetunes the model on the provided list of samples.

        This method must be implemented in subclasses to update or modify 
        the model based on a provided set of annotated samples. Finetuning 
        could involve training the model further on the provided samples 
        to improve its performance for the annotation task.

        Args:
            samples (List[ISample]): A list of annotated samples to finetune 
                                      the model on. Each sample should implement 
                                      the `ISample` interface and contain 
                                      annotations that the model can learn from.

        Raises:
            NotImplementedError: If the method is not implemented by a subclass.
        """
        raise NotImplementedError
    
    @abc.abstractmethod
    def generateAnnotation(self, samples: List[ISample], iteration_id: Any) -> List[ISample]:
        """
        Generates annotations for the provided samples.

        This method must be implemented in subclasses to generate new annotations 
        for the given samples. The annotations generated by the model should be 
        added to the samples, typically in the form of label predictions, and 
        returned as a list.

        Args:
            samples (List[ISample]): A list of samples for which annotations 
                                      need to be generated. Each sample should 
                                      implement the `ISample` interface.
            iteration_id (Any): The identifier of the iteration in which the annotations were being generated.

        Returns:
            List[ISample]: A list of samples with generated annotations.

        Raises:
            NotImplementedError: If the method is not implemented by a subclass.
        """
        raise NotImplementedError
