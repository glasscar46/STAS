from typing import Any, List
from i_entities import IModel
from i_entities import ISample
from i_entities import IDAO
from i_entities import Iteration
from i_entities import IStopCondition
from selector import SelectorFactory
from utils.config_loader import ConfigLoader


class AnnotationController:
    """
    Controls the annotation process, including managing iterations, validation of annotations, 
    and stopping conditions. It interacts with the model, database (DAO), and annotation process.
    """

    def __init__(self, model: IModel, dao: IDAO, config: ConfigLoader) -> None:
        """
        Initializes the AnnotationController with the given model, data access object (DAO), and configuration.

        Args:
            model (IModel): The model responsible for generating annotations.
            dao (IDAO): The data access object for interacting with the database.
            config (ConfigLoader): The configuration loader for managing app settings.
        """
        self._model = model
        self._dao: IDAO = dao
        self._stopping_conditions: List[IStopCondition] = []
        self.current_iteration: Iteration = None
        self.position = 0
        self.config = config
        self.max_iteration = config.get('max-iteration', 10)  # Maximum number of iterations
        self.sample_selector = SelectorFactory(self.config).get_selector()  # Sample selector
        self.sample_size = config.get('sample-size', 100)  # Size of each sample set per iteration

    def validate_annotation(self, sample: ISample, is_valid: bool = False):
        """
        Validates an annotation, marking it as valid or invalid, and persists the result in the database.

        Args:
            sample (ISample): The annotation sample to validate.
            is_valid (bool): Whether the annotation is valid (True) or invalid (False).
        """
        sample.labels.is_valid = is_valid
        sample.validated = is_valid
        self._dao.updateAnnotation(sample)
        if is_valid:
            self._dao.saveSampleAnnotation(sample)  # Save valid annotations
        self.aux()  # Check if stopping conditions are met after each validation

    def run_iterative_process(self):
        """
        Runs the iterative section of the annotation process, starting new iterations until 
        the maximum number of iterations is reached.

        If the number of iterations exceeds the maximum, the process is finalized.
        """
        if self.position < self.max_iteration:
            self.position += 1
            self.startIteration()  # Start a new iteration
        else:
            self.finalize_process()  # Finalize the process after reaching the max iteration

    def run_process(self):
        """
        Starts the annotation process by invoking the iterative process.

        This method is responsible for beginning the iterative annotation process.
        """
        self.run_iterative_process()

    def finalize_process(self):
        """
        Finalizes the annotation process by annotating any remaining samples, 
        running an evaluation, and completing the process.

        This method should be called when the iterative process reaches its conclusion.
        """
        # Annotate all remaining samples and persist
        # Run evaluation (can be implemented later)
        pass

    def aux(self):
        """
        Auxiliary method that evaluates the stopping conditions. If any stopping condition is met, 
        the current iteration is ended, and the process is finalized.

        This method is typically invoked after validating an annotation.
        """
        if self.evaluate_stopping_conditions():
            self.end_iteration()  # End the current iteration if a stopping condition is met
            self.finalize_process()  # Finalize the process if necessary

    def persistModelAnnotations(self, samples: List[ISample]):
        """
        Persists the annotations generated by the model into the database.

        Args:
            samples (List[ISample]): The list of samples for which annotations are generated.
        """
        if self.current_iteration is None:
            return
        self._dao.saveAnnotations([sample.labels for sample in samples])  # Save the model-generated annotations

    def startIteration(self):
        """
        Starts a new iteration of the annotation process, selecting a sample of data, 
        fine-tuning the model, generating annotations, and persisting the results.

        This method creates a new iteration object, saves it, annotates the selected samples, 
        and updates the iteration status.
        """
        samples = self.sample_selector(self._dao).select(self.sample_size)  # Select the sample for annotation
        
        # Fine-tune model with the selected samples
        model = self._model.copy()
        model.finetune(samples)
        model_id = self._dao.saveModel(model)  # Save the fine-tuned model

        # Create a new iteration and save it
        self.current_iteration = Iteration(self.position, model_id, [sample.id for sample in samples])
        self.current_iteration.id = self._dao.saveIteration(self.current_iteration)

        # Generate annotations for the samples and persist them
        samples = model.generateAnnotation(samples)
        self.persistModelAnnotations(samples)

        # Update iteration status to "Annotated"
        self.current_iteration.status = "Annotated"
        self._dao.updateIteration(self.current_iteration)

    def end_iteration(self):
        """
        Ends the current iteration, marking it as completed and triggering the next iteration 
        if applicable. If no more iterations remain, the process is finalized.

        This method is typically called after a stopping condition is met.
        """
        self.current_iteration.status = 'Completed'
        self._dao.updateIteration(self.current_iteration)
        self.current_iteration = None  # Reset current iteration
        self.run_iterative_process()  # Start the next iteration if needed

    def evaluate_stopping_conditions(self) -> bool:
        """
        Evaluates the stopping conditions to check if the annotation process should end.

        Returns:
            bool: True if any of the stopping conditions are met, False otherwise.
        """
        for condition in self._stopping_conditions:
            if condition.evaluate(self.current_iteration):  # Evaluate each stopping condition
                return True
        return False
