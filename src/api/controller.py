from typing import Any, List
from i_entities import IModel
from i_entities import ISample
from i_entities import IDAO
from i_entities import Iteration
from i_entities import IStopCondition
from selector import SelectorFactory
from utils.config_loader import ConfigLoader

class AnnotationController():

    def __init__(self, model: IModel, dao:IDAO, config: ConfigLoader) -> None:
        self._model = model
        self._dao: IDAO = dao
        self._stopping_conditions: List[IStopCondition] = []
        self.current_iteration: Iteration = None
        self.position = 0
        self.config = config
        self.max_iteration = config.get('max-iteration', 10)
        self.sample_selector = SelectorFactory(self.config).get_selector()
        self.sample_size = config.get('sample-size', 100)


    def validate_annotation(self, sample: ISample, is_valid: bool = False):
        """"Handles the validation of annotations."""
        sample.labels.is_valid = is_valid
        sample.validated = is_valid
        self._dao.updateAnnotation(sample)
        self.aux() # TODO resolve when stopiing condition will be evaluated, after all validations or after each 
    
    def run_iterative_process(self):
        """Responsible for controlling the iterative section of annotation process"""
        if self.position < self.max_iteration:
            self.position += 1
            self.startIteration() 
        else:
            self.finalize_process()
    
    def run_process(self):
        """"Starts the annotation process"""
        self.run_iterative_process() 

    def finalize_process(self):
        # Annotate all remaining samples and persist
        # run evaluation
        pass

    def aux(self):
        """The """
        if self.evaluate_stopping_conditions():
            self.end_iteration()
            self.finalize_process()

    def persistModelAnnotations(self, samples: List[ISample]):
        """Pesist the annotations generated by a Model."""
        if self.current_iteration is None:
            return
        self._dao.saveAnnotations([sample.labels for sample in samples])

    def startIteration(self):
        """Starts an iteration"""
        
        samples = self.sample_selector(self._dao).select(self.sample_size)
        
        # finetune model in new thread
        model = self._model.copy()
        model.finetune(samples)
        model_id = self._dao.saveModel(model)
        
        self.current_iteration = Iteration(self.position, model_id, [sample.id for sample in samples])
        
        # Create iteration object and persist
        self.current_iteration.id = self._dao.saveIteration(self.current_iteration)
        
        # Annotate samples and persist
        samples = model.generateAnnotation(samples)
        self.persistModelAnnotations(samples)
        
        # Mark annotation for validation
        self.current_iteration.status = "Annotated"
        self._dao.updateIteration(self.current_iteration)

    def end_iteration(self):
        """Ends the current iteration and triggers the continuation of the annotation process."""
        self.current_iteration.status = 'Completed'
        self._dao.updateIteration(self.current_iteration)
        self.current_iteration = None
        self.run_iterative_process()

    def evaluate_stopping_conditions(self) -> bool:
        """Checks if any of the stopping conditions have been met by the current iteration"""
        for condition in self._stopping_conditions:
            if condition.evaluate(self.current_iteration):
                return True
        return False
